The tar pit

Usando como métáfora um tar pit(poço de piche) em que grandes animais pré-históricos como dinossauros lutam para sair dos poços sem sucesso, não importanto quão feroz seja o animal, ele acaba afundando.

O desenvolvimento de grandes sistemas de computadores, nas últimas décadas têm sido como um poço de pit em que muitos grandes e poderosos softwares têm travado batalhas violentas. Alguns conseguiram construir softwares que rodassem - mas poucos atingiram metas, cronogramas e orçamentos. Nada parece causar a dificuldade. Mas o acúmulo de fatores simultâneos traz um movimento cada vez mais lento. Todos parecem terem sido surpreendidos pela viscosidade do problema e é difícil discernir a natureza dele. Mas devemos tentar entender isso se quisermos solucionar.

É extremamente normal ler notícias de que um par de jovens programadores em uma garagem criaram um programa importante que supera os melhores esforços de uma grande equipe. E todo programdor está preparado para acreditar em tais coisas, pois ele sabe que pode construir software muito mais rápido do que times em indústrias.

Porque então não trocamos todos os times de uma companhia por pares de programadores em garagens? É necessário olhar o que está sendo produzido.

Todos sabemos que esse tipo de programa está pronto para ser executado pelo autor do sistema que desenvolveu. 

Existem dois caminhos para tornar o programa em algo mais usável.

Programming product - O primeiro deles é transformar em um produto de programação. Um programa que pode ser executado, testado, reparado e extendido por qualquer pessoa. Ele é usável em muitos ambientes operacionais, pra vários conjuntos de dados. Para tornar-se um produto usável genericamente, o programa deve ser escrito em um modelo genérico. E possibilitar formas de entrada genéricas. Em seguida, o programa deve ser exaustivamente testado, para que possa confiar. Isso significa que um banco substancial de casos de teste, explorando as possíveis entradas e sondando seus limites deve ser preparado, executado e gravado. Finalmente, promover um programa para um produto requer uma documentação completa, omde qualquer um possa usá-lo, corrigi-lo e extende-lo. Como um principio básico, eu estimo que um produto custa pelo menos três vezes mais que um produto de depuração com a mesma funcionalidade.


Programming System - O segundo, é transformar um programa em sistema. Isso é uma coleção de programas que interagem cordenados para a execução de grandes tarefas. Para ser um componente de sistema , um programa deve ser escrito e todas as entradas e saídas estejam em conformidade com interfaces definidas. Ele também deve ser projetado para usar um conjunto prescrito de recursos- espaço na memória, dispositivos de entrada e saída e tempo de processamento. Finalmente, ele deve ser testado com outros componentes, em todas as combinações esperadas. Esse teste deve ser extenso, pois o número de casos tende a crescer.  Um sistema de componentes custa pelo menos três vezes mais que um programa stand-alone. Esse custo pode aumentar se o sistema tem muitos componentes.

Programming Systems Product - Custa nove vezes mais do que o programa de garagem, mas é verdadeiramente útil e o produto pretendido pela maioria.

## As alegrias do oficio
## Porque a programação é divertida? Quais são as recompensas que um praticante pode esperar?

Primeiro, pela pura alegria de fazer coisas. Como uma criança se diverte com sua torta de lama, um adulto gosta de cosntruir coisas, especialemnte coisas do seu próprio projeto.

Segundo, pelo prazer de fazer coisas que serão úteis para outras pessoas. No fundo, queremos que outras pessoas usem nosso trabalho e o considerem útil.

Terceiro, o fascínio de criar objetos complexos, semelhante a quebra cabeças, de partes interligadas e observá-los trabalhar em ciclos sutis, representando as consequência dos princípios construídos desde o início.

Em quarto, a alegria de estar sempre aprendendo, como estações que não se repetem na natureza das tarefas. Em um ou outro caminho, o problema é sempre novo, e quem soluciona aprende algo. Ora prático, ora teórico, ora ambos.

Finalmente, existe prazer em trabalhar em um meio tão tratável. O programador, como o poeta, trabalha apenas com um pouco de remoção do pensamento puro. Ele constrói seu castelos no ar, para o ar, criando seus esforços na imaginação. Poucos meios de criação são tão flexíveis, fáceis de polir e retrabalhar, prontamente capazes de realizar grandes estruturas conceituais.

No entanto, o programa construído, diferente das palavras do poeta, é real, no sentido que ele se move e trabalha produzindo saídas visíveis, separadas da própria construção. Ele imprime resultados, desenha figuras, produz sons, move braços. A magia dos mitos e lendas se tornou realidade em nosso tempo. Digita-se o encantamento correto em um teclado, e uma tela ganha vida, mostrando coisas que nunca existirar e nem poderiam.

Programar então é divertido porque gratifica os anseios criativos construídos no fundo de nóes e encanta as sensibilidades que temos em comuns com todos os homens.


## As desgraças do ofício


Nem tudo são flores, entretanto, e conhecer os problemas inerentes torna mais fácil suportá-los quando eles aparecem.

Primeiro, é preciso executar perfeitamente. O computador se assemelha a magia da lenda em seu respeito também. Se um caracter, uma pausa do encantamento não está na forma adequada, a mágica não funciona. Os seres humanos não estão acostumados a serem perfeitos, e poucas áreas da atividade humana exigem. Ajustar ao requisito de perfeição é, eu penso, a parte mais difícil de aprender a programar.

Depois, outras pessoas definem os objetivos, provêm recursos e fornecem informações. Raramente se controla as circunstâncias de seu trabalho ou mesmo seu objetivo. Em termos de gestão, a autoridade de alguém não é suficiente por sua responsabilidade. Parece que em todos os campos, entretanto, os empregos onde coisas acabam nunca tem uma autoridade formal proporcional à responsabilidade. Na prática, autoridade real - ao contrário de formal - é adquirida a partir do próprio momento de realização.

A dependência de outros tem um caso particular que é especialmente dolorosa para os programadores de sistema. Ele depende dos programas de outras pessoas. Estes são frequentemente mal projetados, mal implementado, entregue incompleto(sem código fonte ou casos de teste) e pobremente documentados. Então ele deve dispender horas estudando e consertando coisas que em um mundo ideal deveriam estar completos, disponíveis e usáveis.

A próxima tristeza é que projetar grandes conceitos é divertido; encontrar pequenos bugs é apenas trabalho. Como qualquer atividade criativa vem com horas de tédio sombrio, trabalho árdio e programação não é exceção.

Próximo, a depuração tem uma convergência linear, ou pior, onde se espera de alguma forma, um tipo de abordagem quadrática até o fim. Portanto, o teste é contínuo, os últimos bugs difíceis levam mais tempo para serem encontrados do que o primeiro. 

A última lamúria, e talvez a última gota é que o produto pelo qual se trabalhou há tanto tempo parece obsoleto após a conclusão - ou antes. Colegas e concorrentes já estão perseguindo novas e melhores ideias. Nã apenas concebendo, mas agendado.

Isso sempre parece pior do que realmente é. O produto novo e melhor geralmente não está disponível quando alguém completa seu próprio, só se fala sobre. Também exigirá meses de desenvolvimento. O tigre de verdade nunca combina com o de papel, a menos que seja desejado o uso real. Então as virtudes da realidade têm uma satisfação própria.

Claro que a base tecnológica sobre o qual se baseia está sempre avançando. Assim que alguém congela um design, ele se torna obsoleto em termos de seus conceitos. Mas a implementação de produtos reais demanda faseamento e quantização. a obsolência de uma implementação deve ser mensurada contra outras implementações existentes, não contra conceitos não realizados. O desafio e a missão estão em encontrar soluções reais para problemas reais em planejamentos atuais com recursos disponíveis.

Isso então é programação, uma poça de piche no qual muitos esforços patinam e uma atividade criativa com alegrias e lamúrias por si só. Para muitos, as alegrias superam os problemas, e para eles o restante desse livro tentará colocar alguns calçadões atravé do piche.




## discussões de outros autores

Programa - é o que todos nós desenvolvemos. É um simples pedaço de código que é usável pelo programador e um conjunto de usuários que estão diretamente envolvidos em definir seus requisitos. Eles são usuais apenas no contexto original , uma vez que sai do contexto, sua utilidade se decompõe rapidamente. Em adição, eles não foram projetados solidamente para serem extensíveis e certamente não devem ser usados como componentes em um sistema maior. aquele script que vc escreveu para corrigir um problema pontual na sua máquina. O programador e o seu colega são os usuários.

Programming products - Em teoria, todas as aplicações comerciais e aplicações personalizadas com alguma maturidade são programming products. O grande desafio, de acordo com Brooks, eles custam 3x mais do que desenvolver um pedaço de código com alguma funcionalidade. E por isso é tão difícil obter orçamento e cronogramas suficientes para fazer um projeto corretamente. A diferença para quem vê de fora entre um pedaço de código sólido e algo que foi acabado de juntar é muito sútil - é impossível enxergálo em uma demo, mas a diferença de custo é surpreendente. Consequentemente, eu penso que a maioria das aplicações comerciais são lançadas muito antes de estarem maduras.

Programming systems - são programas destinados a serem reutilizados como partes de sistemas maiores. Em termos gerais, são bibliotecas, frameworks, microserviços e outros componentes que estão na moda no desenvolvimento de softwares. Como os programming products, programming systems são completamente testados, documentados e o mais importante são usáveis fora do contexto em que els foram criados. E como os programming products, eles custam 3X mais para desenvolver do que um programa.

Programming System Products - possui as características de um programming product e um programming systems. É útil para uma ampla gama de usuários e pode ser estendido ou incorporado em sistemas maiores. Possui documentação completa e é extensivamente testado. A maioria dos sistemas comerciais persegue isso:
geralmente são integrados a outros produtos, fornecem funcionalidades para uma ampla gama de usuários. é o que todas as empresas de desenvolvimento tentam fazer

O problema é que eles não conseguem por causa da: "the tar pit". Se coloque na posição de gerente de desenvolvimento em um lançamento de um novo produto. Você quer fazer o melhor produto possível. Você sabe que o que você desenvolve hoje servirá como linha de base pelos próximos anos. O produto precisa ser usável, o produto precisa ser extensível, o produto precisa ser testado e documentado. O produto precisa ser barato e precisa ser entregue para ontem.

Desenvolver Um programming System Products custa 9 X mais do que desenvolver um programa com essencialmente as mesmas funcionalidades externas. Isso significa que aos olhos do vendedor ou de um potencial cliente é a mesma coisa. e essa é a luta diária de todos os times de engenharia.

Se o produto tiver vida longa, fazer do jeito certo, reduzirá problemas futuros. Mas desenvolve-lo demandará mais tempo. E este não poderá ter vida longa se ele nunca for liberado. E se o produto somente for liberado quando o mercado estiver inundado com produtos similares, a chance dele ter sucesso é reduzida. 

O resultado final é uma mistura de componentes fortemente acoplados que como os individuais, caem em uma das categorias menores. Existe uma APi documentada, mas a documentação não é tão boa e o código da aplicação reflete isso. A documentação do usuário está desatualizada. Ah, e a aplicação não é realmente tão genérica.

Escapar da Tar Pit - se você desenvolve uma grande aplicação você está destinado a patinar na tar pit porque o barato e o agora substituirão o correto e a próxiam década. Você precisa de um sistema robusto, mas seu orçamento e tempo disponível não podem suportar mais do que um simples programa.

Mas como escapar disso? Aceite. Produtos que dão a impressão externa de serem mais do que realmente são costumam ter falta de integridade conceitual. Se você está construindo uma aplicação, construa isso correto para os usuários. Depois amplie para interagir com outras apicações.

Particione: Alguns pedaços do seu sistema são provavelmente mais importantes que outros. Existem locais onde requisitos serão voláteis ou espcíficos para alguns clientes- estes são os lugares onde você precisa de um sistema verdadeiramente extensível. Você também deve usar fortes abstrações. O código associado com estas abstrações deve ser de alto nível e bem documentado. Outras partes apenas precisam estar funcionando para o usuário.





